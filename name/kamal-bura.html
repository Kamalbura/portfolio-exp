<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kamal Bura Particles</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .btn-swatch {
            transition: transform 0.2s ease;
        }
        .btn-swatch:hover {
            transform: scale(1.1);
        }

        #loading-screen {
            z-index: 50;
            background: #000;
        }

        /* Custom Scrollbar for panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 flex flex-col items-center justify-center text-white transition-opacity duration-1000">
        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-purple-500 mb-4"></div>
        <h2 class="text-2xl font-light tracking-widest">KAMAL BURA</h2>
        <p class="text-gray-500 mt-2 text-sm">Allow camera for hand control</p>
    </div>

    <!-- Hidden Video for Computer Vision -->
    <video id="video-input"></video>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="fixed top-0 left-0 w-full h-full pointer-events-none z-20 p-4 flex flex-col justify-between">
        
        <!-- Header -->
        <div class="pointer-events-auto flex justify-between items-start">
            <div class="glass-panel rounded-xl p-4 flex items-center gap-3">
                <div class="w-2 h-2 rounded-full bg-red-500 animate-pulse" id="status-dot"></div>
                <div>
                    <h1 class="text-white text-sm font-bold tracking-wider">KAMAL BURA PARTICLES</h1>
                    <p class="text-xs text-gray-400" id="status-text">Waiting for hands...</p>
                </div>
            </div>

            <!-- Color Picker -->
            <div class="glass-panel rounded-xl p-2 flex gap-2">
                <button onclick="app.setColor(0xff3366)" class="btn-swatch w-6 h-6 rounded-full bg-[#ff3366] border border-white/20"></button>
                <button onclick="app.setColor(0x33ccff)" class="btn-swatch w-6 h-6 rounded-full bg-[#33ccff] border border-white/20"></button>
                <button onclick="app.setColor(0xffcc33)" class="btn-swatch w-6 h-6 rounded-full bg-[#ffcc33] border border-white/20"></button>
                <button onclick="app.setColor(0xcc33ff)" class="btn-swatch w-6 h-6 rounded-full bg-[#cc33ff] border border-white/20"></button>
                <button onclick="app.setColor(0xffffff)" class="btn-swatch w-6 h-6 rounded-full bg-white border border-white/20"></button>
            </div>
        </div>

        <!-- Camera Preview (Small) -->
        <div class="pointer-events-auto absolute bottom-4 right-4 w-32 h-24 glass-panel rounded-lg overflow-hidden border border-gray-700">
            <canvas id="camera-feed" class="w-full h-full object-cover transform scale-x-[-1]"></canvas>
            <div class="absolute bottom-1 left-1 text-[10px] text-white bg-black/50 px-1 rounded">DEBUG VIEW</div>
        </div>
    </div>

    <script>
        class ParticleApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.count = 8000;
                this.positions = [];
                this.currentPositions = null;
                this.targetColor = new THREE.Color(0xff3366);
                this.handOpenness = 0;
                this.handPosition = { x: 0, y: 0 };
                this.clock = new THREE.Clock();
                this.time = 0;
                this.mouse = new THREE.Vector2();
                this.isHandsDetected = false;

                this.initThree();
                this.initParticles();
                this.initMediaPipe();
                this.animate();
                this.setupResize();
            }

            // --- 1. Three.js Setup ---
            initThree() {
                const container = document.getElementById('canvas-container');
                
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.002);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 30;

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                });
            }

            // --- 2. Particle System ---
            createTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            initParticles() {
                const geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(this.count * 3);
                const colors = new Float32Array(this.count * 3);

                for(let i = 0; i < this.count * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 50;
                    colors[i] = 1;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    map: this.createTexture(),
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);

                this.currentPositions = this.particles.geometry.attributes.position.array;
                this.generateTextShape('KAMAL BURA');

                // Start near the text so the word is visible immediately
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    this.currentPositions[i3] = this.positions[i3] + (Math.random() - 0.5) * 0.5;
                    this.currentPositions[i3 + 1] = this.positions[i3 + 1] + (Math.random() - 0.5) * 0.5;
                    this.currentPositions[i3 + 2] = this.positions[i3 + 2] + (Math.random() - 0.5) * 0.5;
                }
            }

            generateTextShape(text) {
                this.positions = new Float32Array(this.count * 3);

                // Draw text to offscreen canvas and sample its alpha to build target points.
                const canvas = document.createElement('canvas');
                const width = 1000;
                const height = 300;
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 200px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, width / 2, height / 2);

                const data = ctx.getImageData(0, 0, width, height).data;
                const samples = [];
                for (let y = 0; y < height; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = (y * width + x) * 4 + 3; // alpha channel
                        if (data[idx] > 128) samples.push({ x, y });
                    }
                }

                // If text sampling fails, fall back to a sphere.
                const useSphereFallback = samples.length === 0;

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    let x, y, z;

                    if (!useSphereFallback) {
                        const p = samples[Math.floor(Math.random() * samples.length)];
                        const nx = (p.x / width) * 2 - 1; // -1 to 1
                        const ny = (p.y / height) * 2 - 1;
                        const scale = 14; // text size in world units
                        x = nx * scale;
                        y = -ny * scale * 0.5; // compensate aspect
                        z = (Math.random() - 0.5) * 2.0; // small depth jitter
                    } else {
                        const r = 10 * Math.cbrt(Math.random());
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }

                    this.positions[i3] = x;
                    this.positions[i3 + 1] = y;
                    this.positions[i3 + 2] = z;
                }
            }

            setColor(hex) {
                this.targetColor.setHex(hex);
            }

            // --- 3. Animation Loop ---
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time += 0.01;
                const delta = this.clock.getDelta();

                let factor = 1;
                if (this.isHandsDetected) {
                    factor = 0.5 + (this.handOpenness * 2.5); // 0.5 to 3
                } else {
                    factor = 1 + Math.sin(this.time * 2) * 0.3;
                }

                const positions = this.particles.geometry.attributes.position.array;
                const colors = this.particles.geometry.attributes.color.array;

                for(let i = 0; i < this.count; i++) {
                    const i3 = i * 3;

                    const tx = this.positions[i3];
                    const ty = this.positions[i3+1];
                    const tz = this.positions[i3+2];

                    const expansion = factor;

                    positions[i3] += ((tx * expansion) - positions[i3]) * 0.1;
                    positions[i3+1] += ((ty * expansion) - positions[i3+1]) * 0.1;
                    positions[i3+2] += ((tz * expansion) - positions[i3+2]) * 0.1;

                    colors[i3] += (this.targetColor.r - colors[i3]) * 0.05;
                    colors[i3+1] += (this.targetColor.g - colors[i3+1]) * 0.05;
                    colors[i3+2] += (this.targetColor.b - colors[i3+2]) * 0.05;
                }

                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.geometry.attributes.color.needsUpdate = true;

                let targetRotY = this.isHandsDetected ? (this.handPosition.x - 0.5) * 2 : this.mouse.x;
                let targetRotX = this.isHandsDetected ? (this.handPosition.y - 0.5) * 2 : this.mouse.y;
                
                this.particles.rotation.y += (targetRotY - this.particles.rotation.y) * 0.05;
                this.particles.rotation.x += (targetRotX - this.particles.rotation.x) * 0.05;
                this.particles.rotation.z += 0.002;

                this.renderer.render(this.scene, this.camera);
            }

            setupResize() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            // --- 4. MediaPipe Integration ---
            initMediaPipe() {
                const videoElement = document.getElementById('video-input');
                const canvasElement = document.getElementById('camera-feed');
                const canvasCtx = canvasElement.getContext('2d');

                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                    
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                        drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
                        
                        this.processHandData(landmarks);
                        this.isHandsDetected = true;
                        document.getElementById('status-dot').className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";
                        document.getElementById('status-text').innerText = "Hand Connected";
                    } else {
                        this.isHandsDetected = false;
                        document.getElementById('status-dot').className = "w-2 h-2 rounded-full bg-red-500 animate-pulse";
                        document.getElementById('status-text').innerText = "Waiting for hands...";
                    }
                    canvasCtx.restore();
                });

                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });

                camera.start()
                    .then(() => {
                        document.getElementById('loading-screen').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('loading-screen').style.display = 'none';
                        }, 1000);
                    })
                    .catch(err => {
                        console.error(err);
                        alert("Camera access denied or not available. Mouse fallback enabled.");
                        document.getElementById('loading-screen').style.display = 'none';
                    });
            }

            processHandData(landmarks) {
                const wrist = landmarks[0];
                const tip = landmarks[12];
                const thumbTip = landmarks[4];
                const pinkyTip = landmarks[20];
                
                const distanceY = Math.sqrt(
                    Math.pow(tip.x - wrist.x, 2) + 
                    Math.pow(tip.y - wrist.y, 2)
                );

                const distanceX = Math.sqrt(
                    Math.pow(thumbTip.x - pinkyTip.x, 2) + 
                    Math.pow(thumbTip.y - pinkyTip.y, 2)
                );
                
                let openness = (distanceY - 0.2) * 2.5; 
                openness = Math.max(0, Math.min(1, openness));

                this.handOpenness = openness;
                this.handPosition = { x: wrist.x, y: wrist.y };
            }
        }

        const app = new ParticleApp();
    </script>
</body>
</html>
